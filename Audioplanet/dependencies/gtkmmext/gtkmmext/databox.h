// -*- c++ -*-
//  Generated by gtkmmproc from ./databox.gen_h -- DO NOT MODIFY!
#ifndef _GTKMM_DATABOX_H
#define _GTKMM_DATABOX_H

/* This is -*- C++ -*- */
/* A gtk-- wrapper for Roland Bock's GtkDatabox widget  */
/* Copyright (C) 1999 Oliver Freyd
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
#include <gtk--/box.h>
#include <gtk--/drawingarea.h>
#include <gtk--/table.h>
#include <gdk--/color.h>
#include <gtkmmext/gtkdatabox.h>

namespace Gtk {
class Databox;
class Databox_Class;
}
namespace Gtk { Gtk::Databox *wrap (GtkDatabox *o); }
namespace Gtk
{
class Databox: public VBox {

public:
  typedef Databox          CppObjectType;
  typedef Databox_Class    CppClassType;
  typedef GtkDatabox           BaseObjectType;
  typedef GtkDataboxClass      BaseClassType;

private:
  friend class Databox_Class;
  static CppClassType databox_class;

  Databox(const Databox&);
  Databox& operator=(const Databox&); // not implemented

protected:
  void   initialize_class();
  explicit Databox(GtkDatabox *castitem);

public:
  static GtkType get_type();
  GtkDatabox* gtkobj()             { return (GtkDatabox*)(gtkobject); }
  const GtkDatabox* gtkobj() const { return (GtkDatabox*)(gtkobject); }
  static bool isA(Object *checkcast);

  // Hook for proxies
  static const char* const signal_names[];

  virtual ~Databox();

private:

public:
  Databox();

  Gtk::Table* get_table() const;

  Gtk::DrawingArea* get_draw() const;

//  WRAP_MEMBER(value,drawingarea,draw,Gtk::DrawingArea*,GtkWidget*);
  DrawingArea * get_drawingarea(){return &draw_;}
  const  DrawingArea * get_drawingarea() const {return &draw_;}
//  static bool isGtkDatabox(Gtk::Object *checkcast);



  void show_rulers();



  void hide_rulers();



  void show_cross();



  void hide_cross();



  void show_scrollbars();



  void hide_scrollbars();



  void enable_zoom();



  void disable_zoom();



  void data_get_value(GtkDataboxCoord coord,GtkDataboxValue* value);



  void data_get_extrema(GtkDataboxValue* min,GtkDataboxValue* max);



  void data_get_visible_extrema(GtkDataboxValue* min,GtkDataboxValue* max);



  void rescale();



  void rescale_with_values(GtkDataboxValue min,GtkDataboxValue max);



  void redraw();
  /*
 WRAP_METHOD(
  gint gtk_databox_get_color(GtkDatabox*,gint,GdkColor *),
  gint get_color(gint index, GdkColor & color)
   );
  */
  /*
 WRAP_METHOD(
  gint gtk_databox_set_color(GtkDatabox*,gint,  GdkColor *),
  gint set_color(gint index, GdkColor color)
 );
  */



  gint get_data_type(gint index,GtkDataboxDataType* type,guint* dot_size);



  gint set_data_type(gint index,GtkDataboxDataType type,guint dot_size);

  gint data_add_x_y(guint length,gfloat* X,gfloat* Y,GdkColor color,GtkDataboxDataType type,guint dot_size);

  gint data_add_x(guint length,gfloat* X,gint shared_Y_index,GdkColor color,GtkDataboxDataType type,guint dot_size);

  gint data_add_y(guint length,gfloat* Y,gint shared_X_index,GdkColor color,GtkDataboxDataType type,guint dot_size);





  gint data_remove(gint index);



  gint data_remove_all();



  gint data_destroy(gint index);



  gint data_destroy_all();



 /* void set_data(guint numsets, GtkDataboxDataType *type,guint *set_points,
       gfloat **X,gfloat **Y, gfloat **Z);*/




  void data_get_marked_value(GtkDataboxValue* value);



  void data_get_delta_value(GtkDataboxValue* value);



//  const GtkDatabox* gtkobj() const { return GTK_DATABOX(gtkobject); }
//  GtkDatabox* gtkobj() { return GTK_DATABOX(gtkobject); }
protected:
  DrawingArea draw_;

public:

  union
    {
      CppObjectType * databox_self;
      Gtk::ProxySignal2<void,GtkDataboxValue*,GtkDataboxValue*,CppObjectType,BaseObjectType,0> gtk_databox_zoomed;
      Gtk::ProxySignal1<void,GtkDataboxCoord*,CppObjectType,BaseObjectType,1> gtk_databox_marked;
      Gtk::ProxySignal1<void,GtkDataboxCoord*,CppObjectType,BaseObjectType,2> gtk_databox_selection_started;
      Gtk::ProxySignal2<void,GtkDataboxCoord*,GtkDataboxCoord*,CppObjectType,BaseObjectType,3> gtk_databox_selection_changed;
      Gtk::ProxySignal2<void,GtkDataboxCoord*,GtkDataboxCoord*,CppObjectType,BaseObjectType,4> gtk_databox_selection_stopped;
      Gtk::ProxySignal0<void,CppObjectType,BaseObjectType,5> gtk_databox_selection_canceled;
    };

protected:
  // impl functions
    virtual void gtk_databox_zoomed_impl(GtkDataboxValue* p0,GtkDataboxValue* p1);
    virtual void gtk_databox_marked_impl(GtkDataboxCoord* p0);
    virtual void gtk_databox_selection_started_impl(GtkDataboxCoord* p0);
    virtual void gtk_databox_selection_changed_impl(GtkDataboxCoord* p0,GtkDataboxCoord* p1);
    virtual void gtk_databox_selection_stopped_impl(GtkDataboxCoord* p0,GtkDataboxCoord* p1);
    virtual void gtk_databox_selection_canceled_impl();

};

}

#endif
